[{"authors":null,"categories":null,"content":"I joined the research group \u0026ldquo;Health \u0026amp; Longevity\u0026rdquo; at the Vienna Institute of Demography in August 2017. My work focuses on the measurement of health and mortality. This webpage includes mainly information on my research but I might also post about not work-related topics.\n  Download my resumé.\n","date":1625356800,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":1625356800,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"/author/markus-sauerberg/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/author/markus-sauerberg/","section":"authors","summary":"I joined the research group \u0026ldquo;Health \u0026amp; Longevity\u0026rdquo; at the Vienna Institute of Demography in August 2017. My work focuses on the measurement of health and mortality. This webpage includes mainly information on my research but I might also post about not work-related topics.","tags":null,"title":"Markus Sauerberg","type":"authors"},{"authors":null,"categories":null,"content":"吳恩達 is a professor of artificial intelligence at the Stanford AI Lab. His research interests include distributed robotics, mobile computing and programmable matter. He leads the Robotic Neurobiology group, which develops self-reconfiguring robots, systems of self-organizing robots, and mobile sensor networks.\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Sed neque elit, tristique placerat feugiat ac, facilisis vitae arcu. Proin eget egestas augue. Praesent ut sem nec arcu pellentesque aliquet. Duis dapibus diam vel metus tempus vulputate.\n","date":-62135596800,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":-62135596800,"objectID":"e87efdfe209d90ea3c6332a7cbd9d08b","permalink":"/author/%E5%90%B3%E6%81%A9%E9%81%94/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/author/%E5%90%B3%E6%81%A9%E9%81%94/","section":"authors","summary":"吳恩達 is a professor of artificial intelligence at the Stanford AI Lab. His research interests include distributed robotics, mobile computing and programmable matter. He leads the Robotic Neurobiology group, which develops self-reconfiguring robots, systems of self-organizing robots, and mobile sensor networks.","tags":null,"title":"吳恩達","type":"authors"},{"authors":[],"categories":[],"content":"\rDeath counts in Germany between 2019 and 2020\rIn the light of the COVID-19 pandemic, researchers and journalists were highly interested in comparing the observed number of deaths in 2020 with annual death counts from previous years. Further, there is a still ongoing discussion about the impact of COVID-19 on life expectancy (LE). The relationship between increases/decreases in the annual death count observed in a year and changes in LE is not as clear as often suggested. In the following, I would like to share my analysis on the age distribution of deaths in 2019 and 2020, hoping to create some clarification. The calculations are based on mortality data for women and men in Germany downloaded from Desatis.\nlibrary(openxlsx)\rsetwd(\u0026quot;d:/Rcode/Data\u0026quot;)\r###Data is available at www.destatis.de\rDeaths.m \u0026lt;- read.xlsx(\u0026quot;Sterbefälle.xlsx\u0026quot;, sheet=\u0026quot;Men\u0026quot;)\rDeaths.f \u0026lt;- read.xlsx(\u0026quot;Sterbefälle.xlsx\u0026quot;, sheet=\u0026quot;Women\u0026quot;)\rDx.2019.m \u0026lt;- Deaths.m$Deaths2019\rDx.2020.m \u0026lt;- Deaths.m$Deaths2020\rDx.2019.f \u0026lt;- Deaths.f$Deaths2019\rDx.2020.f \u0026lt;- Deaths.f$Deaths2020\rrbind(\rcbind(X2019=sum(Dx.2019.m),\rX2020=sum(Dx.2020.m),\rDiff=sum(Dx.2019.m)-sum(Dx.2020.m)\r),\rcbind(X2019=sum(Dx.2019.f),\rX2020=sum(Dx.2020.f),\rDiff=sum(Dx.2019.f)-sum(Dx.2020.f)\r)\r)\r## X2019 X2020 Diff\r## [1,] 465885 492797 -26912\r## [2,] 473635 492775 -19140\rThe output shown above gives the total death count for men (first row) and women (second row) in 2019 and 2020. The difference between the two years is presented in the last column of the table. We observe more deaths in 2020 compared to 2019 for both genders. We know from previous analyses that excess deaths were not equally distributed over time and across regions. For example, the number of deaths was particularly high at the end of 2020. Analyzing these differences is, however, beyond the scope of this post. Instead, I focus on the average and calculate the mean age at death (MAD), the mode (the age with the highest observed death count), and the median (the age at which 50 percent of the total number of deaths have occurred). Please let me know if you know a better way to derive mode and median (maybe with decimals) without getting too sophisticated (e.g., modeling and predicting counts).\nage \u0026lt;- 0:100\rMAD.2019.m \u0026lt;- (sum((age+0.5)*Dx.2019.m))/sum(Dx.2019.m)\rMAD.2020.m \u0026lt;- (sum((age+0.5)*Dx.2020.m))/sum(Dx.2020.m)\rMode.2019.m \u0026lt;- age[which.max(Dx.2019.m)]\rMode.2020.m \u0026lt;- age[which.max(Dx.2020.m)]\rMedian.2019.m \u0026lt;- age[which(cumsum(Dx.2019.m)\u0026gt;=(sum(Dx.2019.m)/2))[1]]\rMedian.2020.m \u0026lt;- age[which(cumsum(Dx.2020.m)\u0026gt;=(sum(Dx.2020.m)/2))[1]]\rMAD.2019.f \u0026lt;- (sum((age+0.5)*Dx.2019.f))/sum(Dx.2019.f)\rMAD.2020.f \u0026lt;- (sum((age+0.5)*Dx.2020.f))/sum(Dx.2020.f)\rMode.2019.f \u0026lt;- age[which.max(Dx.2019.f)]\rMode.2020.f \u0026lt;- age[which.max(Dx.2020.f)]\rMedian.2019.f \u0026lt;- age[which(cumsum(Dx.2019.f)\u0026gt;=(sum(Dx.2019.f)/2))[1]]\rMedian.2020.f \u0026lt;- age[which(cumsum(Dx.2020.f)\u0026gt;=(sum(Dx.2020.f)/2))[1]]\rrbind(\rcbind(MAD.2019=MAD.2019.m,\rMAD.2020=MAD.2020.m,\rDiff=MAD.2019.m-MAD.2020.m\r),\rcbind(MAD.2019=MAD.2019.f,\rMAD.2020=MAD.2020.f,\rDiff=MAD.2019.f-MAD.2020.f\r)\r)\r## MAD.2019 MAD.2020 Diff\r## [1,] 76.05939 76.47146 -0.4120715\r## [2,] 81.92622 82.18910 -0.2628851\rThe MAD increased for both, women and men between 2019 and 2020. Accordingly, the analysis suggest that more people have died in 2020 but most deaths have occurred at relatively old ages. It is correct that this kind of analysis does not take into account changes in the age structure. Germany is an aging population and more persons at older ages will necessarily lead to an increase in the observed death count. The following graph shows the observed distribution of death. The vertical lines indicate the MAD, the modal age at death, and the median.\rEspecially at higher ages (between 80 and 90), more deaths have been observed in 2020 compared to the previous year. More information about the relationship between longevity and trends in the mean age at death, modal age at death, and median age at death can be found in Canudas-Romo (2010).\n\rStandardized Mean Age at Death\rIn the next step, I will calculate another MAD which is less common but, I believe, very interesting. It is the standardized MAD which has been described by Bongaarts and Feeney (2003). The standardized MAD is the mean age at death that would have been observed if the present population had experienced a constant inflow of births. In other words, the initial size of each birth cohort is constant or how Guillot (2006) put it “MAD can be interpreted as the population mean age at death at time t, controlling for changes in the initial size of cohorts.” I used the cohort life tables provided by Destatis in order to calculate the standardized number of deaths in 2019 and 2020. This allows obtaining standardized MAD, mode, and median values.\n###Standardized death count calculated on the basis of cohort life tables provided at www.destatis.de\rlibrary(openxlsx)\rsetwd(\u0026quot;d:/Rcode/Data\u0026quot;)\rDx.standardized \u0026lt;- read.table(\u0026quot;MAD_dx.txt\u0026quot;)\rStd.Dx.2019.m \u0026lt;- Dx.standardized$dx.2019[Dx.standardized$Sex==\u0026quot;M\u0026quot;]*100000\rStd.Dx.2020.m \u0026lt;- Dx.standardized$dx.2020[Dx.standardized$Sex==\u0026quot;M\u0026quot;]*100000\rStd.Dx.2019.f \u0026lt;- Dx.standardized$dx.2019[Dx.standardized$Sex==\u0026quot;F\u0026quot;]*100000\rStd.Dx.2020.f \u0026lt;- Dx.standardized$dx.2020[Dx.standardized$Sex==\u0026quot;F\u0026quot;]*100000\rage \u0026lt;- 0:100\rStd.MAD.2019.m \u0026lt;- (sum((age+0.5)*Std.Dx.2019.m))/sum(Std.Dx.2019.m)\rStd.MAD.2020.m \u0026lt;- (sum((age+0.5)*Std.Dx.2020.m))/sum(Std.Dx.2020.m)\rStd.Mode.2019.m \u0026lt;- age[which.max(Std.Dx.2019.m)]\rStd.Mode.2020.m \u0026lt;- age[which.max(Std.Dx.2020.m)]\rStd.Median.2019.m \u0026lt;- age[which(cumsum(Std.Dx.2019.m)\u0026gt;=(sum(Std.Dx.2019.m)/2))[1]]\rStd.Median.2020.m \u0026lt;- age[which(cumsum(Std.Dx.2020.m)\u0026gt;=(sum(Std.Dx.2020.m)/2))[1]]\rStd.MAD.2019.f \u0026lt;- (sum((age+0.5)*Std.Dx.2019.f))/sum(Std.Dx.2019.f)\rStd.MAD.2020.f \u0026lt;- (sum((age+0.5)*Std.Dx.2020.f))/sum(Std.Dx.2020.f)\rStd.Mode.2019.f \u0026lt;- age[which.max(Std.Dx.2019.f)]\rStd.Mode.2020.f \u0026lt;- age[which.max(Std.Dx.2020.f)]\rStd.Median.2019.f \u0026lt;- age[which(cumsum(Std.Dx.2019.f)\u0026gt;=(sum(Std.Dx.2019.f)/2))[1]]\rStd.Median.2020.f \u0026lt;- age[which(cumsum(Std.Dx.2020.f)\u0026gt;=(sum(Std.Dx.2020.f)/2))[1]]\rrbind(\rcbind(MAD.2019=Std.MAD.2019.m,\rMAD.2020=Std.MAD.2020.m,\rDiff=Std.MAD.2019.m-Std.MAD.2020.m\r),\rcbind(MAD.2019=Std.MAD.2019.f,\rMAD.2020=Std.MAD.2020.f,\rDiff=Std.MAD.2019.f-Std.MAD.2020.f\r)\r)\r## MAD.2019 MAD.2020 Diff\r## [1,] 76.37203 76.56336 -0.1913279\r## [2,] 81.83031 81.96213 -0.1318239\rBy definition, this measure is not affected by changes in the age structure. Also the standardized MAD increased between 2019 and 2020. The standardized distribution is smoother as compared to the unstandardized one, indicating that some of the bumps can be ascribed to differences in the size of birth cohorts.\n\rPeriod life expectancy in 2019 and 2020\rLast but not least, I provide estimates for the most prominent mortality indicator, i.e., period life expectancy at birth (LE). As a reminder, LE is the mean age at death for the period life table population. The life table population is derived from age-specific death rates which are again provided by Destatis. This is the exact link: https://www.destatis.de/DE/Presse/Pressemitteilungen/2021/07/PD21_331_12621.html. I simply copied the values from the table to my R session, e.g., “Germany.mx.2019.women \u0026lt;- c(…)” (code is omitted). Please note, the death rates refer to 5-years age intervals. For this reason, I calculated an abridged life table. The R package DemoTools\" by Tim Riffe et al. (2019) helped me. Thanks! The LE values for 2019 and 2020 in Germany based on single-age specific period life tables will be published at www.lebenserwartung.info and differ slightly from the LE estimates presented in this post (the single-age specific life tables with an open age-interval at higher ages yield more precise LE estimates).\n###Following the DemoTools documentation example, the abridged life table is constructed as:\rlibrary(DemoTools)\r## Lade nötiges Paket: Rcpp\rAge \u0026lt;- c(0, 1, seq(5, 95, by = 5))\rAgeInt \u0026lt;- age2int(Age,OAvalue = 5)\rLE.women.2019 \u0026lt;- lt_abridged(Age=Age, nMx = Germany.mx.2019.women/1000, sex = \u0026quot;female\u0026quot;,\rAgeInt = AgeInt, axmethod = \u0026quot;un\u0026quot;, mod = FALSE, OAnew = 100, a0rule =\u0026quot;cd\u0026quot;)\rLE.women.2020 \u0026lt;- lt_abridged(Age=Age, nMx = Germany.mx.2020.women/1000, sex = \u0026quot;female\u0026quot;,\rAgeInt = AgeInt, axmethod = \u0026quot;un\u0026quot;, mod = FALSE, OAnew = 100, a0rule =\u0026quot;cd\u0026quot;)\rLE.men.2019 \u0026lt;- lt_abridged(Age=Age, nMx = Germany.mx.2019.men/1000, sex = \u0026quot;male\u0026quot;,\rAgeInt = AgeInt, axmethod = \u0026quot;un\u0026quot;, mod = FALSE, OAnew = 100, a0rule =\u0026quot;cd\u0026quot;)\rLE.men.2020 \u0026lt;- lt_abridged(Age=Age, nMx = Germany.mx.2020.men/1000, sex = \u0026quot;male\u0026quot;,\rAgeInt = AgeInt, axmethod = \u0026quot;un\u0026quot;, mod = FALSE, OAnew = 100, a0rule =\u0026quot;cd\u0026quot;)\r###Compare LE estimates by age\r###Men in Germany\rround(cbind(Age=Age[c(1,15)],\rLE.2019=LE.men.2019$ex[c(1,15)],\rLE.2020=LE.men.2020$ex[c(1,15)],\rDiff=LE.men.2019$ex[c(1,15)]-LE.men.2020$ex[c(1,15)]),2)\r## Age LE.2019 LE.2020 Diff\r## [1,] 0 78.86 78.69 0.17\r## [2,] 65 18.15 17.92 0.23\r###Women in Germany\rround(cbind(Age=Age[c(1,15)],\rLE.2019=LE.women.2019$ex[c(1,15)],\rLE.2020=LE.women.2020$ex[c(1,15)],\rDiff=LE.women.2019$ex[c(1,15)]-LE.women.2020$ex[c(1,15)]),2)\r## Age LE.2019 LE.2020 Diff\r## [1,] 0 83.64 83.55 0.10\r## [2,] 65 21.35 21.23 0.12\r###getting mode\rMode.LT.2019.f \u0026lt;- Age[which.max(LE.women.2019$ndx)]\rMode.LT.2020.f \u0026lt;- Age[which.max(LE.women.2020$ndx)]\rMode.LT.2019.m \u0026lt;- Age[which.max(LE.men.2019$ndx)]\rMode.LT.2020.m \u0026lt;- Age[which.max(LE.men.2020$ndx)]\rAs presented in the table above, LE slightly decreased for both genders. The distribution of life table deaths is plotted below. It shows the age-specific number of deaths for the life table cohort which has been exposed to the age-specific mortality rates observed in Germany.\rThis time I do not calculate the median because, as already mentioned, data was only available in 5-years age intervals. The median should lay somewhere in the age interval 80-84 for men and 85-89 for women. The MAD (or LE) in the period life table population is higher compared to the the unstandardized and standardized MAD. Another way to look at LE is imagining Germany would be trapped in a loop where it repeats the year 2020 over and over again for about 100 years (I know, nobody wants this). A lucky child who is born at the beginning of this loop can expect to live 83.55 years in case it´s a girl and 78.69 years if it´s a boy. Obviously, this scenario is unlikely and LE is usually not a good estimate for the expected life time of any actual group of individuals (Goldstein and Wachter 2006). It is rather a convenient way to summarize period death rates and examine period shocks in health and mortality. The increase in the observed death rates for the elderly in 2020 is reflected by the decrease in period LE in 2020. Yet, the indicator is not free of limitations and can lead to misleading conclusions regarding levels and trends in population health (Luy et al. 2020; Modig, Rau, and Ahlbom 2020; Heuveline 2021). In comparison to other countries, Germany`s LE reduction is small. It is important to note that changes in death rates at different ages will affect LE differently (Vaupel 1986). It is therefore not so easy to translate increases in death counts at any age directly into LE reductions. For instance, the reduction in LE is higher at age 65 compared to LE at birth, indicating that death rates have mostly increased at older ages. The largest increase in mortality is observed for older men (LE at age 65 decreased by 0.23 years between 2019 and 2020). For more information about differences in LE in Germany, including differences between genders, East and West Germany, socioeconomic groups, and regions, see Marc Luy´s webpage www.lebenserwartung.info and for more country-specific results see the work by Aburto et al. (2021), which also features an interactive dashboard.\n\rReferences\r\rCanudas-Romo, V. (2010). Three Measures of Longevity: Time Trends and Record Values. Demography 47(2):299–312.\n\rBongaarts, J. and Feeney, G. (2003). Estimating mean lifetime. PNAS 100(23):13127-13133.\n\rGuillot, M. (2006). Tempo effects in mortality: An appraisal. Demographic Research 41(1):1-26.\n\rRiffe, T., Aburto, J.M., Alexander, M., Fennell, S., Kashnitsky, I., Pascariu, M., Gerland, P. (2019). DemoTools: An R package of tools for aggregate demographic analysis. github.com/timriffe/DemoTools.\n\rGoldstein, J., \u0026amp; Wachter, K. (2006). Relationships between Period and Cohort Life Expectancy: Gaps and Lags. Population Studies 60(3):257-269.\n\rLuy, M., Di Giulio, P., Di Lego, V., Lazarevič, P., Sauerberg, M. (2020). Life Expectancy: Frequently Used, but Hardly Understood. Gerontology 66:95-104.\n\rModig, K., Rau, R., Ahlbom, A. (2020). Life expectancy: what does it measure? BMJ Open 10(7):e035932.\n\rHeuveline, P. (2021). The Mean Unfulfilled Lifespan (MUL): A new indicator of the impact of mortality shocks on the individual lifespan, with application to mortality reversals induced by COVID-19. PLoS ONE 16(7):e0254925.\n\rVaupel, J. (1986). How changes in age-specific mortality affects life expectancy. Population Studies 40:147-157.\n\rAburto, J.M., Schöley, J., Zhang, L., Kashnitsky, I., Rahal, C., Missov, T.I., Mills, M.C., Dowd, J.B., Kashyap, R. (2021). Recent Gains in Life Expectancy Reversed by the COVID-19 Pandemic. Medrxiv Link.\n\r\r\r","date":1628640000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1628666565,"objectID":"33ee6bd000bf47540fd6fad475b133c6","permalink":"/post/leingermany/","publishdate":"2021-08-11T00:00:00Z","relpermalink":"/post/leingermany/","section":"post","summary":"Death counts in Germany between 2019 and 2020\rIn the light of the COVID-19 pandemic, researchers and journalists were highly interested in comparing the observed number of deaths in 2020 with annual death counts from previous years.","tags":[],"title":"Period life expectancy in Germany","type":"post"},{"authors":["Simone Ghislandi","Raya Muttarak","Markus Sauerberg\"","Bendedetta Scotti"],"categories":null,"content":"","date":1626912000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1626912000,"objectID":"5e0bc15816e1d424980b06531b0869cf","permalink":"/publication/vyrb/","publishdate":"2021-07-22T00:00:00Z","relpermalink":"/publication/vyrb/","section":"publication","summary":"Deaths from COVID-19 can be miscounted due to under-reporting and inaccurate death registration. Mortality is often reported at the national level, which can result in the underestimation of the true scale of the impact of the pandemic since outbreaks tend to be localised. This study exploits all-cause daily death registration data provided by the Italian Statistical Office (ISTAT) from 1 January to 31 October to estimate the excess mortality and the corresponding changes in life expectancy during the first wave of the COVID-19 pandemic. Focusing on the five most severely hit provinces in Italy (Bergamo, Brescia, Cremona, Lodi and Piacenza), we calculate the excess mortality in 2020 compared to the average mortality of the years 2015 to 2019. Moreover, we estimate the excess mortality in the first quadrimester of 2020, and the annual life expectancy at birth. The estimated excess deaths show that during this period, mortality was significantly higher than the official mortality statistics for COVID-19. According to our estimates for the first quadrimester, life expectancy in the five provinces declined by 5.4 to 8.1 for men and by 4.1 to 5.8 years for women. In addition, we find that annual life expectancy decreased by 2.4 to 4.1 years for men and by 1.9 to 2.8 years for women compared to the 2015–2019 average. Thus, we conclude that the first wave of the COVID-19 pandemic had a substantial impact on population health in the hardest hit areas in Italy.","tags":null,"title":"Human costs of the first wave of the COVID-19 pandemic in the major epicenters in Italy","type":"publication"},{"authors":[],"categories":[],"content":"\rObjective\rAfter reading the book “History of Codes” by Simon Singh, I was inspired to apply some of the things that I have learned in R. While the book describes the history of codes in terms of encrpyting and decrypting messages (e.g., for secret communication), I will focus on managing passwords. Please note that the following is written for fun and should not be interpreted as an attempt to develop a flawless password manager. It is rather my first try of writing an encryption function. I hope it is useful for generating passwords for conferences, journals, or shopping webpages.\n\rBackground\rEncryption can be seen as substituting letters. As an example, each of the 26 letters of the alphabet could be shifted by one letter. This would result in “A -\u0026gt; B”, “B -\u0026gt; C”, “C -\u0026gt; D” and so forth. Using this substitution algorithm, the encryption of my name “Markus” results in “Nbslvt”. In order to decipher the word “Nbslvt” back to “Markus” one would need the key, i.e., a table indicating how the letters have been substituted. Obviously, the “shifted-by-one-letter” cipher can be figured out quite easily by most amateur code breakers and is not very safe. Throughout history scientists came up with much more sophisticated cipher codes and cipher machines in order to keep communication private. Especially, during the first and second World War secret communication became crucial for the military. With the rapid expansion of the internet, encrypting messages was no longer only a matter for governments and the military but also relevant for ordinary individuals. In my opinion, one of the most fascinating encryption technique is the Rivest–Shamir–Adleman (RSA) cryptosystem. This breakthrough idea uses one-way functions (functions that cannot easily be inverted) and the practical difficulty of factoring two prime numbers. The algorithm is without a doubt as genius and geeky as it gets. This video gives a very vivid explanation: Eddie Woo YouTube.\n\rMy implementation in R\rMy idea is much more simple and relies on combining the substitution of letters with randomly selected numbers. In other words, I do not use an algorithm such as shifting the alphabet by \\(x\\) characters, as I have described above, but let the sample() function in R determine the substitution pattern. More specifically, each letter in the encrypted word will be based on its own sample() call. The word “Hallo”, for example, contains the letter “l” twice (third and forth element of the string). The sample() function might lead to a substitution of “l -\u0026gt; k” for the first “l” and the second “l” might be substituted with b (l -\u0026gt; b). This makes is much harder to break the encryption code because of the extremely high number of substitution possibilities. The key for the encryption function is the given by the set.seed() argument. The set.seed() function suspends the randomness in the sample() call and therefore allows transforming the letters back to their original order.\n\rThe choice of the alphabet\rMy alphabet includes all 26 letters (in lower- and upper-case spelling), the numbers \\(0\\) to \\(9\\), and a selection of special characters (!§$%\u0026amp;/()=?@*#\u0026lt;\u0026gt;_-.;+{}[]). The code can be easily modified in order to incorporate more special characters, i.e., Germans might want a “ö”, while Danes require “ø”, and the French prefer “ô”.\nCipherWord \u0026lt;- function(my.password, my.key) {\rset.seed(my.key)\rthe.length \u0026lt;- length(unlist(strsplit(my.password, \u0026quot;\u0026quot;)))\rthe.vec \u0026lt;- unlist(strsplit(my.password, \u0026quot;\u0026quot;))\rspecials \u0026lt;- c(unlist(strsplit(\u0026quot;!§$%\u0026amp;/()=?@*#\u0026lt;\u0026gt;_-.;+{}[]\u0026quot;, \u0026quot;\u0026quot;)))\rall.characters \u0026lt;- c(letters, LETTERS, 0:9, specials)\rif (!all(the.vec %in% all.characters)) {\rstop(\u0026quot;unkown character(s) in password\u0026quot;)\r}\rcipher.list \u0026lt;- NULL\rfor (i in 1:the.length) {\rcipher.frame \u0026lt;- data.frame(alphabet = all.characters)\rcipher.frame$alphabet \u0026lt;- levels(droplevels(cipher.frame$alphabet))\rcipher.frame$cipher.num \u0026lt;- sample(1:length(cipher.frame$alphabet), length(cipher.frame$alphabet))\rcipher.frame$cipherbet \u0026lt;- cipher.frame[order(cipher.frame$cipher.num), ]$alphabet\rcipher.list[[i]] \u0026lt;- cipher.frame\r}\rencrypted.password \u0026lt;- c()\rfor (j in 1:the.length) {\rencrypted.letter \u0026lt;- unlist(strsplit(my.password, \u0026quot;\u0026quot;))[j]\rencrypted.password[j] \u0026lt;- cipher.list[[j]]$cipherbet[match(encrypted.letter, cipher.list[[j]]$alphabet)]\r}\rcount \u0026lt;- any(encrypted.password %in% specials) +\rany(encrypted.password %in% letters) +\rany(encrypted.password %in% LETTERS)\rif(count!=3) {\rwarning(\u0026quot;Encryption does not include lower, upper, and special characters\u0026quot;)\r}\rout \u0026lt;- rbind(cbind(\u0026quot;Original\u0026quot;,\u0026quot;Encrypted\u0026quot;),cbind(my.password,\rpaste(encrypted.password,collapse=\u0026quot;\u0026quot;)))\rreturn(out)\r}\r# basically copy and paste\rDecipherWord \u0026lt;- function(my.encrypted.word, my.key) {\rset.seed(my.key)\rthe.length \u0026lt;- length(unlist(strsplit(my.encrypted.word, \u0026quot;\u0026quot;)))\rthe.vec \u0026lt;- unlist(strsplit(my.encrypted.word, \u0026quot;\u0026quot;))\rspecials \u0026lt;- c(unlist(strsplit(\u0026quot;!§$%\u0026amp;/()=?@*#\u0026lt;\u0026gt;_-.;+{}[]\u0026quot;, \u0026quot;\u0026quot;)))\rall.characters \u0026lt;- c(letters, LETTERS, 0:9, specials)\rif (!all(the.vec %in% all.characters)) {\rstop(\u0026quot;unkown character(s) in the encrypted word\u0026quot;)\r}\rcipher.list \u0026lt;- NULL\rfor (i in 1:the.length) {\rcipher.frame \u0026lt;- data.frame(alphabet = all.characters)\rcipher.frame$alphabet \u0026lt;- levels(droplevels(cipher.frame$alphabet))\rcipher.frame$cipher.num \u0026lt;- sample(1:length(cipher.frame$alphabet), length(cipher.frame$alphabet))\rcipher.frame$cipherbet \u0026lt;- cipher.frame[order(cipher.frame$cipher.num), ]$alphabet\rcipher.list[[i]] \u0026lt;- cipher.frame\r}\rdecrypted.password \u0026lt;- c()\rfor (j in 1:the.length) {\rdecrypted.letter \u0026lt;- unlist(strsplit(my.encrypted.word, \u0026quot;\u0026quot;))[j]\rdecrypted.password[j] \u0026lt;- cipher.list[[j]]$alphabet[match(decrypted.letter, cipher.list[[j]]$cipherbet)]\r}\rout \u0026lt;- rbind(cbind(\u0026quot;Encrypted\u0026quot;,\u0026quot;Decrypted\u0026quot;),cbind(my.encrypted.word,\rpaste(decrypted.password,collapse=\u0026quot;\u0026quot;)))\rreturn(out)\r}\r\rHow does it work?\rImagine you are accepted at a conference and the upload of the paper requires setting up an account with your Email address and a password. You would love to choose an easy word such as “EasyPassword” but you are aware that this is neither secure nor accepted by most webpages. With the functions that I have provided above, it is possible to transform “EasyPassword” to “Q/VX@ezlQptv”. The CipherWord() function requires the word that you would like to encrypt and a key number (for set.seed). The key number becomes the user’s personal encryption key. One option to use CipherWord() is remembering one personal key and choosing easy passwords such as “PasswordPAA2021” for PAA in 2021 or “PasswordEPC2022” for EPC in 2022. Alternatively, the user can keep the password constant but change the encryption key. The encryption key might be based on a fancy function, refer to the date of a given conference, or the session number of the presentation. In the following example, I encrypt “EasyPassword” with the key “123” to the much safer password “Q/VX@ezlQptv”. The DecipherWord() function reverses the encryption as long as the user knows the right key (“123” in the example). Accordingly, the function can also be used to inform close colleagues (with access to the encryption key) about the secret lunch date location ^_^\nCipherWord(\u0026quot;EasyPassword\u0026quot;, 123)\r## my.password ## [1,] \u0026quot;Original\u0026quot; \u0026quot;Encrypted\u0026quot; ## [2,] \u0026quot;EasyPassword\u0026quot; \u0026quot;Q/VX@ezlQptv\u0026quot;\rDecipherWord(\u0026quot;Q/VX@ezlQptv\u0026quot;, 123)\r## my.encrypted.word ## [1,] \u0026quot;Encrypted\u0026quot; \u0026quot;Decrypted\u0026quot; ## [2,] \u0026quot;Q/VX@ezlQptv\u0026quot; \u0026quot;EasyPassword\u0026quot;\r\rThe challenge of password requirements\rI encounter mostly webpages with the requirement of selecting a password that includes lower- and upper case letters as well as at least one special character. At the moment, the function CipherWord() gives you a warning in case this requirements are not met. It is also possible to modify the function in a way that it automatically forces this combination of letters whenever necessary. However, the empirical analysis shown below indicates that this issue is relatively rare. Especially, if the input word is not too short (choosing a relative long password is actually always a good idea). For this reason, I do not take any specific password requirements into account for the moment.\nspecials \u0026lt;- c(unlist(strsplit(\u0026quot;!§$%\u0026amp;/()=?@*#\u0026lt;\u0026gt;_-.;+{}[]\u0026quot;, \u0026quot;\u0026quot;)))\ryes \u0026lt;- 0\rno \u0026lt;- 0\rfor (i in 1:100) {\rthe.word \u0026lt;- CipherWord(\u0026quot;EasyPassword\u0026quot;, i)[2,2]\rthe.word \u0026lt;- unlist(strsplit(the.word, \u0026quot;\u0026quot;))\rcount \u0026lt;- any(the.word %in% specials) +\rany(the.word %in% letters) +\rany(the.word %in% LETTERS)\rif (count==3) {\ryes \u0026lt;- yes+1\r}else{\rno \u0026lt;- no+1\r}\r}\r## Warning in CipherWord(\u0026quot;EasyPassword\u0026quot;, i): Encryption does not include lower,\r## upper, and special characters\r## Warning in CipherWord(\u0026quot;EasyPassword\u0026quot;, i): Encryption does not include lower,\r## upper, and special characters\r## Warning in CipherWord(\u0026quot;EasyPassword\u0026quot;, i): Encryption does not include lower,\r## upper, and special characters\r## Warning in CipherWord(\u0026quot;EasyPassword\u0026quot;, i): Encryption does not include lower,\r## upper, and special characters\rbars \u0026lt;- barplot(cbind(yes,no), col=\u0026quot;lightgray\u0026quot;,\rmain=\u0026quot;Include lower-, upper-, and specical characters?\u0026quot;,\rcex.main=1.5\r)\rtext(bars, 40, paste(cbind(yes,no), \u0026quot;times\u0026quot;, \u0026quot; \u0026quot;), cex=1.5)\rNow, the same procedure but with a longer input word (LongerPasswordsAreBetter).\nyes \u0026lt;- 0\rno \u0026lt;- 0\rfor (i in 1:100) {\rthe.word \u0026lt;- CipherWord(\u0026quot;LongerPasswordsAreBetter\u0026quot;, i)[2,2]\rthe.word \u0026lt;- unlist(strsplit(the.word, \u0026quot;\u0026quot;))\rcount \u0026lt;- any(the.word %in% specials) +\rany(the.word %in% letters) +\rany(the.word %in% LETTERS)\rif (count==3) {\ryes \u0026lt;- yes+1\r}else{\rno \u0026lt;- no+1\r}\r}\rbars \u0026lt;- barplot(cbind(yes,no), col=\u0026quot;lightgray\u0026quot;,\rmain=\u0026quot;Include lower-, upper-, and specical characters?\u0026quot;,\rcex.main=1.5\r)\rtext(bars, 40, paste(cbind(yes,no), \u0026quot;times\u0026quot;, \u0026quot; \u0026quot;), cex=1.5)\r\rReferences\r\rSingh, Simon (2002). The Code Book: The Secret History of Codes and Code-Breaking. Harper Collins Publishers UK: (Reissue) Edition.\r\r\r","date":1626220800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1626241691,"objectID":"b3c3570cb314245ee612344d66e1238c","permalink":"/post/crypto/","publishdate":"2021-07-14T00:00:00Z","relpermalink":"/post/crypto/","section":"post","summary":"Generate a strong password from an easy one","tags":["R Coding","DecipheR"],"title":"Encrypting (pass)words in R","type":"post"},{"authors":["Markus Sauerberg"],"categories":["Demography"],"content":"Deriving education-specific life tables with an iterative process The life table survivors at age $x$ ($l_x$) can be obtained from life expectancy estimates at age $x$ ($e_x$) after assuming that in each age interval $x$ to $x+1$, people dying within this period live on average $1/2$ person-years ($a_x=0.5$): \\begin{equation} l_{x+1}=\\frac{l_x \\cdot (2 \\cdot e_x -1)}{1+2 \\cdot e_{x+1}}. \\end{equation} Please note, $l_0$ denotes the life table radix (usually defined as 100 000) and does not require estimation. Thus, the life table reconstruction starts with deriving $l_1$: \\begin{equation} l_{1}=\\frac{l_0 \\cdot (2 \\cdot e_0 -1)}{1+2 \\cdot e_{1}}. \\end{equation} In this way, the life table survivors at age 1 can be estimated from three known life table functions, i.e., $l_0$, $e_0$, and $e_1$. In the next step, $l_2$ is estimated from $l_1$, $e_1$, and $e_2$ and so forth. Once all $l_x$ are estimated on the basis of this algorithm, the remaining life table functions can be easily derived, such as $L_x$ ($L_x=(l_x+l_{x+1})/2)$. Theoretically, equation 1 enables us to reconstruct life table functions based on $e_x$ values (under the $a_x$ = 0.5 assumption). In practice, however, the reconstruction might require additional steps. For example, the $e_x$ values provided by Eurostat have only one decimal place. This limits the accuracy of the $l_x$ derivation and might result in constant $l_x$ values for several ages. To overcome this issue, we fitted a non-parametric curve to the data and predicted $e_x$ values with more decimal places. More specifically, we used the loess() function in R in order to obtain $e_x$ values with more decimal places that are as close as possible to the original $e_x$ values. In some cases, e.g., for the highly educated subpopulation in very low-mortality countries, the proposed derivation procedure still produces constant $l_x$ values at young ages. We solved this issue by focusing on $e_{30}$ and HLY at age 30.\nThe following code provides an example for calculating education-specific life tables when only the education-specific $e_x$ values are known. In other words, the aim of the code is to calculate the life table backwards, namely from $e_x$ to $p_x$. This is necessary because Eurostat does not provide education-specific life tables, but education-specific $e_x$ values are available. Please note, the results in this example will differ from the results in my paper (Sauerberg 2021) due to updates in the Eurostat database.\nlibrary(dplyr)\rlibrary(eurostat)\r#please load these packages and download the data like this:\rdata \u0026lt;- get_eurostat(\u0026quot;demo_mlexpecedu\u0026quot;, time_format = \u0026quot;num\u0026quot;)\r#rename and redefine the file data$isced11 \u0026lt;- as.character(data$isced11)\rdata$isced11 \u0026lt;- ifelse(data$isced11==\u0026quot;ED0-2\u0026quot;, \u0026quot;lower\u0026quot;, data$isced11)\rdata$isced11 \u0026lt;- ifelse(data$isced11==\u0026quot;ED3_4\u0026quot;, \u0026quot;middle\u0026quot;, data$isced11)\rdata$isced11 \u0026lt;- ifelse(data$isced11==\u0026quot;ED5-8\u0026quot;, \u0026quot;higher\u0026quot;, data$isced11)\rdata$isced11 \u0026lt;- ifelse(data$isced11==\u0026quot;TOTAL\u0026quot;, \u0026quot;total\u0026quot;, data$isced11)\rdata$age \u0026lt;- as.character(data$age)\rdata$age \u0026lt;- ifelse(data$age==\u0026quot;Y_LT1\u0026quot;, \u0026quot;Y0\u0026quot;, data$age)\rdata$age \u0026lt;- ifelse(data$age==\u0026quot;Y_GE85\u0026quot;, \u0026quot;Y85\u0026quot;, data$age)\rdata$age \u0026lt;- substring(data$age, 2)\rdata \u0026lt;- data[,-1]\rcolnames(data) \u0026lt;- c(\u0026quot;sex\u0026quot;,\u0026quot;age\u0026quot;,\u0026quot;edu\u0026quot;,\u0026quot;country\u0026quot;,\u0026quot;year\u0026quot;,\u0026quot;ex\u0026quot;)\rdata$age \u0026lt;- as.numeric(data$age)\r#Filter for the year 2016, as we have done\rdata \u0026lt;- filter(data, year==2016)\r The following function has the arguments \u0026ldquo;country.select\u0026rdquo;, \u0026ldquo;edu.select\u0026rdquo; and \u0026ldquo;sex.select\u0026rdquo;. Thus, the funcation allows to derive life tables for each educational level (high, middle, low, and total), for each country with available data (16 European countries), separated for men and women.\nmy.function \u0026lt;- function(country.select, edu.select, sex.select) {\rselect.country \u0026lt;- arrange(filter(data, country==country.select ,edu==edu.select \u0026amp;\rsex==sex.select),age)\r#smooth to get more decimals by applying the loess function,\r#then predict ex with more decimals\rgrab.LE \u0026lt;- select.country$ex\rsmooth.it \u0026lt;- loess(grab.LE~select.country$age, span=0.2)\rpredict.it \u0026lt;- predict(smooth.it, seq(0,85,1))\rselect.country$ex.decimals \u0026lt;- predict.it\rLT.derive \u0026lt;- data.frame(Age=0:85)\rLT.derive$lx \u0026lt;- NA\rLT.derive$ex \u0026lt;- select.country$ex.decimals\rLT.derive$lx[1] \u0026lt;- 100000\rLT.derive$Tx[1] \u0026lt;- 100000*select.country$ex.decimals[1]\r#this loop refers to equation 1 in the paper\rfor (j in 2:86) {\rupper \u0026lt;- LT.derive$lx[j-1]*(2*LT.derive$ex[j-1]-1)\rbottom \u0026lt;- 1+2*LT.derive$ex[j]\rLT.derive$lx[j] \u0026lt;- upper/bottom\r}\r#Checks if lx is monotonic decreasing, i.e., no resurrection in the life table\rlx.diff \u0026lt;- diff(LT.derive$lx)\rlx.diff \u0026lt;- round(lx.diff, 5)\rif (all(diff(lx.diff) \u0026lt; 0)) {\rpx \u0026lt;- c(LT.frame$lx[-1]/LT.frame$lx[-86],0)\r}else{\r#sometimes, it is not, so I force it =)\r#please note, this occurs usually at very young ages and won't affect\r#LE at age 30 or older\rlx.diff[lx.diff\u0026gt;=0] \u0026lt;- -runif(length(lx.diff[lx.diff\u0026gt;=0]), 1, 5)\rlx.monotonic \u0026lt;- cumsum(c(100000, lx.diff))\rpx \u0026lt;- c(lx.monotonic[-1]/lx.monotonic[-86],0)\r}\r#from here, the life table is constructed very standardly\rlx \u0026lt;- round(c(100000, (cumprod(px)*100000)[1:(length(px)-1)]))\rdx \u0026lt;- round(c(-diff(lx), lx[length(lx)]))\rLT.derive$lx \u0026lt;- lx\rLT.derive$dx \u0026lt;- dx\rLT.derive$px \u0026lt;- px\rLx1 \u0026lt;- lx[-1]+0.5[-length(px)]*dx[-length(dx)]\rLx.open \u0026lt;- LT.derive$Tx[1]-sum(Lx1)\rLT.derive$Lx \u0026lt;- round(c(Lx1, Lx.open))\rLT.derive$Tx \u0026lt;- rev(cumsum(rev(LT.derive$Lx)))\rLT.derive$ex.derived \u0026lt;- LT.derive$Tx/LT.derive$lx\rLT.derive$ex.original \u0026lt;- select.country$ex\rLT.derive$diff \u0026lt;- LT.derive$ex.original-LT.derive$ex.derived\rLT.derive$Country \u0026lt;- country.select\rLT.derive$Edu \u0026lt;- edu.select\rLT.derive$Sex \u0026lt;- sex.select\rreturn(LT.derive[,c(\u0026quot;Country\u0026quot;,\u0026quot;Edu\u0026quot;,\u0026quot;Sex\u0026quot;,\u0026quot;Age\u0026quot;,\u0026quot;px\u0026quot;,\u0026quot;lx\u0026quot;,\u0026quot;dx\u0026quot;,\u0026quot;Lx\u0026quot;,\r\u0026quot;Tx\u0026quot;,\u0026quot;ex.derived\u0026quot;,\u0026quot;ex.original\u0026quot;,\u0026quot;diff\u0026quot;)])\r}\r The following code applies the function to all 16 European countries by educational attainment, stratified by sex.\n#these are the country codes\redu.countries \u0026lt;- c(\u0026quot;BG\u0026quot;,\u0026quot;DK\u0026quot;,\u0026quot;EE\u0026quot;,\u0026quot;EL\u0026quot;,\u0026quot;HR\u0026quot;,\u0026quot;IT\u0026quot;,\u0026quot;HU\u0026quot;, #CZ is currently not available\r\u0026quot;PL\u0026quot;,\u0026quot;PT\u0026quot;,\u0026quot;RO\u0026quot;,\u0026quot;SI\u0026quot;,\u0026quot;SK\u0026quot;,\u0026quot;FI\u0026quot;,\u0026quot;SE\u0026quot;,\u0026quot;NO\u0026quot;)\r###Females###\rout.females \u0026lt;- c()\rfor (country.select in edu.countries) {\rfor (edu.select in c(\u0026quot;higher\u0026quot;,\u0026quot;middle\u0026quot;,\u0026quot;lower\u0026quot;)) {\rout.females \u0026lt;- rbind(out.females,my.function(country.select, edu.select, \u0026quot;F\u0026quot;))\r}\r}\r###Males###\rout.males \u0026lt;- c()\rfor (country.select in edu.countries) {\rfor (edu.select in c(\u0026quot;higher\u0026quot;,\u0026quot;middle\u0026quot;,\u0026quot;lower\u0026quot;)) {\rout.males \u0026lt;- rbind(out.males,my.function(country.select, edu.select, \u0026quot;M\u0026quot;))\r}\r}\r Finally, I plot the difference between the original $e_x$ and the derived $e_x$.\npar(mfrow=c(3,3))\rfor (edu in c(\u0026quot;higher\u0026quot;,\u0026quot;middle\u0026quot;,\u0026quot;lower\u0026quot;)) {\rplot(1,1, type=\u0026quot;n\u0026quot;, xlim=c(1,16), ylim=c(-0.2,0.2),\rmain=paste(\u0026quot;Females\u0026quot;,edu,sep=\u0026quot; \u0026quot;), xlab=\u0026quot;Countries\u0026quot;,\rylab=\u0026quot;LE 30 original - LE30 derived\u0026quot;)\rpoints(1:15,out.females$diff[out.females$Edu==edu \u0026amp; out.females$Age==30])\rtext(1:15,out.females$diff[out.females$Edu==edu \u0026amp; out.females$Age==30], 1:16,\rlabel=out.females$Country[out.females$Edu==edu \u0026amp; out.females$Age==30])\r}\rfor (edu in c(\u0026quot;higher\u0026quot;,\u0026quot;middle\u0026quot;,\u0026quot;lower\u0026quot;)) {\rplot(1,1, type=\u0026quot;n\u0026quot;, xlim=c(1,16), ylim=c(-0.2,0.2),\rmain=paste(\u0026quot;Males\u0026quot;,edu,sep=\u0026quot; \u0026quot;), xlab=\u0026quot;Countries\u0026quot;,\rylab=\u0026quot;LE 30 original - LE30 derived\u0026quot;)\rpoints(1:15,out.males$diff[out.males$Edu==edu \u0026amp; out.males$Age==30])\rtext(1:15,out.males$diff[out.males$Edu==edu \u0026amp; out.males$Age==30], 1:16,\rlabel=out.males$Country[out.males$Edu==edu \u0026amp; out.males$Age==30])\r}\r Complete life tables by age and education (stratified by women and men) This prints all the age- and education-specific life tables (the output it omitted).\nlibrary(knitr)\rtable.fun \u0026lt;- function(country.select) {\rprint(\rkable(filter(out.females, Country==country.select \u0026amp; Edu==\u0026quot;higher\u0026quot;),\rdigits=4, caption=paste(\u0026quot;Life table for high-educated women in\u0026quot;,\rcountry.select,\u0026quot;, 2016\u0026quot;,sep=\u0026quot; \u0026quot;)) )\rprint(\rkable(filter(out.females, Country==country.select \u0026amp; Edu==\u0026quot;middle\u0026quot;),\rdigits=4, caption=paste(\u0026quot;Life table for middle-educated women in\u0026quot;,\rcountry.select,\u0026quot;, 2016\u0026quot;,sep=\u0026quot; \u0026quot;)) )\rprint(\rkable(filter(out.females, Country==country.select \u0026amp; Edu==\u0026quot;lower\u0026quot;),\rdigits=4, caption=paste(\u0026quot;Life table for low-educated women in\u0026quot;,\rcountry.select,\u0026quot;, 2016\u0026quot;,sep=\u0026quot; \u0026quot;))\r)\rprint(\rkable(filter(out.males, Country==country.select \u0026amp; Edu==\u0026quot;higher\u0026quot;),\rdigits=4, caption=paste(\u0026quot;Life table for high-educated men in\u0026quot;,\rcountry.select,\u0026quot;, 2016\u0026quot;,sep=\u0026quot; \u0026quot;)) )\rprint(\rkable(filter(out.males, Country==country.select \u0026amp; Edu==\u0026quot;middle\u0026quot;),\rdigits=4, caption=paste(\u0026quot;Life table for middle-educated men in\u0026quot;,\rcountry.select,\u0026quot;, 2016\u0026quot;,sep=\u0026quot; \u0026quot;)) )\rprint(\rkable(filter(out.males, Country==country.select \u0026amp; Edu==\u0026quot;lower\u0026quot;),\rdigits=4, caption=paste(\u0026quot;Life table for low-educated men in\u0026quot;,\rcountry.select,\u0026quot;, 2016\u0026quot;,sep=\u0026quot; \u0026quot;)) ) }\rfor (country in edu.countries) {\rtable.fun(country) }\r References  Sauerberg, M. (2021). The imapact of population\u0026rsquo;s educational attainment on Healthy Life Years in Europe: An empirical illustration of 16 European countries. SSM - Population Health, 15(100857).  ","date":1625356800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1625356800,"objectID":"279b9966ca9cf3121ce924dca452bb1c","permalink":"/post/getting-started/","publishdate":"2021-07-04T00:00:00Z","relpermalink":"/post/getting-started/","section":"post","summary":"This R code might help you reconstructing life table functions when only ex is known","tags":["R coding"],"title":"Reconstruction life table functions from life expectancy","type":"post"},{"authors":null,"categories":null,"content":"","date":1625270400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1625270400,"objectID":"d1311ddf745551c9e117aa4bb7e28516","permalink":"/project/external-project/","publishdate":"2021-07-03T00:00:00Z","relpermalink":"/project/external-project/","section":"project","summary":"I built this app in cooporation with my colleague Vanessa Di Lego.","tags":null,"title":"Shiny App for testing prevalence smoothing","type":"project"},{"authors":["Markus Sauerberg"],"categories":null,"content":"","date":1624665600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1624665600,"objectID":"db0576ebd4f0943817353a763cfd0ac7","permalink":"/publication/hlyedu/","publishdate":"2021-06-26T00:00:00Z","relpermalink":"/publication/hlyedu/","section":"publication","summary":"Healthy life years (HLY) is a prominent summary indicator for evaluating and comparing the levels of population health status across Europe. Variations in HLY, however, do not necessarily reflect underlying differences in health and mortality levels among countries and the indicator is particularly sensitive when broken down by subpopulations. For instance, despite European countries showing large HLY inequalities by educational level, these countries are also heterogenous regarding their population composition by educational attainment, which most likely affects their HLY levels. We demonstrate how this compositional effect shapes HLY levels by providing estimates for HLY by educational attainment and gender for 16 European countries using the Sullivan method. We use prevalence data about limitations in daily activities from the European Union Statistics on Income and Living Conditions (EU-SILC) and mortality data from the Eurostat database. Finally, we adjust for compositional effects by means of standardization. The education-adjusted HLY estimates do not differ much from conventional HLY. Yet, we find that in some countries HLY levels are indeed affected by the population composition by educational attainment. For example, low-, medium-, and high educated individuals in Portugal show more HLY than their counterparts in Poland. Still, Poland’s total HLY value slightly exceeds that of Portugal, indicating favorable health and mortality conditions in Poland. It is Poland’s lower relative number of low educated individuals in its population that is responsible for producing this higher total HLY value. We conclude that differentials in HLY due to differences in the relative size of educational subpopulations are generally small in HLY across Europe but they can play an important role for countries that experienced large differences in their educational expansion.","tags":null,"title":"The impact of population's educational composition on Healthy Life Years: An empirical illustration of 16 European countries","type":"publication"},{"authors":["Markus Sauerberg"],"categories":null,"content":"","date":1622073600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1622073600,"objectID":"dde066f6e7467dadccb5772ca702125d","permalink":"/publication/popeurope/","publishdate":"2021-05-27T00:00:00Z","relpermalink":"/publication/popeurope/","section":"publication","summary":"The article is about mortality levels in Germany and other European countries during the COVID-19 pandemic. The work was supported by Max-Planck-Gesellschaft  zur  Förderung  der  Wissenschaften e. V. im Namen des Netzwerks „Population Europe‟ and Bundesministerium für Familie, Senioren, Frauen und Jugend.","tags":null,"title":"Das Mortalitätsgeschehen während der COVID-19-Pandemie in Deutschland und anderen europäischen Ländern","type":"publication"},{"authors":null,"categories":null,"content":"","date":1620385200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1620385200,"objectID":"193de6e55974732914e4fc8168295fa8","permalink":"/talk/paa-2021-in-session-socioeconomic-status-and-mortality-in-europe/","publishdate":"2021-05-07T13:00:00+02:00","relpermalink":"/talk/paa-2021-in-session-socioeconomic-status-and-mortality-in-europe/","section":"event","summary":"The paper's name is: Assessing Population Health on the Basis of Healthy Life Expectancy in 16 European Countries: Educational Inequalities and the Impact of the Population Structure","tags":null,"title":"PAA 2021 in session: Socioeconomic Status and Mortality in Europe","type":"event"},{"authors":["Markus Sauerberg","Michel Guillot","Marc Luy"],"categories":null,"content":"","date":1598832000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1598832000,"objectID":"75c87eb4e5aaee824df63162d2760ba8","permalink":"/publication/hcal/","publishdate":"2020-08-31T00:00:00Z","relpermalink":"/publication/hcal/","section":"publication","summary":"Healthy life years have superseded life expectancy (LE) as the most important indicator for population health. The most common approach to separate the total number of life years into those spent in good and poor health is the Sullivan method which incorporates the health dimension to the classic period life table, thus transforming the LE indicator into the health expectancy (HE) indicator. However, life years derived from a period life table and health prevalence derived from survey data are based on different conceptual frameworks. We modify the Sullivan method by combining the health prevalence data with the conceptually better fitting cross-sectional average length of life (CAL). We refer to this alternative HE indicator as the “cross-sectional average length of healthy life” (HCAL). We compare results from this alternative indicator with the conventional Sullivan approach for nine European countries. The analyses are based on EU-SILC data in three empirical applications, including the absolute and relative level of healthy life years, changes between 2008 and 2014, and the extent of the gender gap. HCAL and conventional HE differ in each of these empirical applications. In general, HCAL provides larger gains in healthy life years in recent years, but at the same time greater declines in the proportion of healthy life years. Regarding the gender gap, HCAL provides a more favourable picture for women compared to conventional HE. Nonetheless, the extent of these differences between the indicators is only of minor extent. Albeit the differences between HE and HCAL are small, we found some empirical examples in which the two indicators led to different conclusions. It is important to note, however, that the measurement of health and the data quality are much more important for the healthy life years indicator than the choice of the variant of the Sullivan method. Nonetheless, we suggest to use HCAL in addition to HE whenever possible because it widens the spectrum of empirical analyses and serves for verification of results based on the highly sensitive HE indicator.","tags":null,"title":"The cross-sectional average length of healthy life (HCAL): a measure that summarizes the history of cohort health and mortality","type":"publication"},{"authors":["Marc Luy","Paola Di Giulio","Vanessa Di Lego","Patrick Lazarevič","Markus Sauerberg"],"categories":null,"content":"","date":1565136000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1565136000,"objectID":"a35f39bdab51c1b4e80c971bcf7f6bac","permalink":"/publication/le/","publishdate":"2019-08-07T00:00:00Z","relpermalink":"/publication/le/","section":"publication","summary":"Period life expectancy is one of the most used summary indicators for the overall health of a population. Its levels and trends direct health policies, and researchers try to identify the determining risk factors to assess and forecast future developments. The use of period life expectancy is often based on the assumption that it directly reflects the mortality conditions of a certain year. Accordingly, the explanation for changes in life expectancy are typically sought in factors that have an immediate impact on current mortality conditions. It is frequently overlooked, however, that this indicator can also be affected by at least three kinds of effects, in particular in the situation of short-term fluctuations: cohort effects, heterogeneity effects, and tempo effects. We demonstrate their possible impact with the example of the almost Europe-wide decrease in life expectancy in 2015, which caused a series of reports about an upsurge of a health crisis, and we show that the consideration of these effects can lead to different conclusions. Therefore, we want to raise an awareness concerning the sensitivity of life expectancy to sudden changes and the menaces a misled interpretation of this indicator can cause.","tags":null,"title":"Life Expectancy: Frequently Used, but Hardly Understood","type":"publication"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"f26b5133c34eec1aa0a09390a36c2ade","permalink":"/admin/config.yml","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/admin/config.yml","section":"","summary":"","tags":null,"title":"","type":"wowchemycms"},{"authors":null,"categories":null,"content":"Good health is central to human happiness and wellbeing. It also contributes substantially to economic progress, as healthy populations live longer and are more productive. Accordingly, the EU defined the improvement of health as a fundamental element of its \u0026ldquo;Europe 2020\u0026rdquo; strategy. The corresponding public health policies are assessed on the basis of a structural indicator for \u0026ldquo;Health Expectancy\u0026rdquo; (HE). Unfortunately, HE estimates are extremely sensitive to certain methodological issues of which many are widely ignored. First, the common measurement of population health by the responses to specific survey questions is ambiguous. As a consequence, statistics on levels and trends of HE vary significantly depending on the underlying survey data and health indicators. Almost completely unrecognized is a second problem: HE estimates are also highly sensitive to particular technical features, e.g. the age range and partitioning selected for analysis and the technique chosen to add the health dimension to the life table. The efforts that have been hitherto undertaken to improve the estimation of HE focus primarily on the measurement of health with surveys, whereas the effects of the chosen HE indicator, data and method remain largely unexplored. The central aim of LETHE is to fill these gaps through a systematic exploration of the HE indicator\u0026rsquo;s sensitivity to these issues. To emphasize the empirical significance of the research, the effects will be investigated in the context of some major actual research questions, in particular the \u0026ldquo;compression versus expansion of morbidity\u0026rdquo; debate and the differences in HE between European populations and subpopulations. Finally, the project aims to identify the particular health measure that is most strongly associated with people\u0026rsquo;s actual happiness. These innovative approaches feature the potential to provide not only new insights into the levels and trends of HE, but also about its main drivers and causation mechanisms.\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"8f66d660a9a2edc2d08e68cc30f701f7","permalink":"/project/internal-project/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/project/internal-project/","section":"project","summary":"Understanding its measurement and estimation sensitivity","tags":null,"title":"Levels and trends of health expectancy","type":"project"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"70d15435870364619f87831beadea30b","permalink":"/slides/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/slides/","section":"","summary":"","tags":null,"title":"Posts","type":"page"}]